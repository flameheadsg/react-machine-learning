{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfc = require(\"@tensorflow/tfjs-core\");\n\nvar util_1 = require(\"util\");\n\nvar gBackend = null;\n\nfunction nodeBackend() {\n  if (gBackend === null) {\n    gBackend = tfc.ENV.findBackend('tensorflow');\n  }\n\n  return gBackend;\n}\n\nexports.nodeBackend = nodeBackend;\n\nfunction getTFDType(dataType) {\n  var binding = nodeBackend().binding;\n\n  switch (dataType) {\n    case 'float32':\n      return binding.TF_FLOAT;\n\n    case 'int32':\n      return binding.TF_INT32;\n\n    case 'bool':\n      return binding.TF_BOOL;\n\n    case 'complex64':\n      return binding.TF_COMPLEX64;\n\n    default:\n      throw new Error('Unknown dtype `${dtype}`');\n  }\n}\n\nexports.getTFDType = getTFDType;\n\nfunction createTypeOpAttr(attrName, dtype) {\n  return {\n    name: attrName,\n    type: nodeBackend().binding.TF_ATTR_TYPE,\n    value: getTFDType(dtype)\n  };\n}\n\nexports.createTypeOpAttr = createTypeOpAttr;\n\nfunction createTensorsTypeOpAttr(attrName, tensors) {\n  if (util_1.isNullOrUndefined(tensors)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  return {\n    name: attrName,\n    type: nodeBackend().binding.TF_ATTR_TYPE,\n    value: getTFDTypeForInputs(tensors)\n  };\n}\n\nexports.createTensorsTypeOpAttr = createTensorsTypeOpAttr;\n\nfunction getTFDTypeForInputs(tensors) {\n  if (util_1.isNullOrUndefined(tensors)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  if (util_1.isArray(tensors)) {\n    for (var i = 0; i < tensors.length; i++) {\n      return getTFDType(tensors[i].dtype);\n    }\n\n    return -1;\n  } else {\n    return getTFDType(tensors.dtype);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}